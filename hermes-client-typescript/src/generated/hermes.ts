// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: hermes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "hermes";

/** How to combine scores for multi-valued documents */
export enum MultiValueCombiner {
  /** COMBINER_LOG_SUM_EXP - Log-sum-exp smooth maximum (default) */
  COMBINER_LOG_SUM_EXP = 0,
  /** COMBINER_MAX - Take maximum score */
  COMBINER_MAX = 1,
  /** COMBINER_AVG - Average all scores */
  COMBINER_AVG = 2,
  /** COMBINER_SUM - Sum all scores */
  COMBINER_SUM = 3,
  /** COMBINER_WEIGHTED_TOP_K - Weighted top-k with decay */
  COMBINER_WEIGHTED_TOP_K = 4,
  UNRECOGNIZED = -1,
}

export function multiValueCombinerFromJSON(object: any): MultiValueCombiner {
  switch (object) {
    case 0:
    case "COMBINER_LOG_SUM_EXP":
      return MultiValueCombiner.COMBINER_LOG_SUM_EXP;
    case 1:
    case "COMBINER_MAX":
      return MultiValueCombiner.COMBINER_MAX;
    case 2:
    case "COMBINER_AVG":
      return MultiValueCombiner.COMBINER_AVG;
    case 3:
    case "COMBINER_SUM":
      return MultiValueCombiner.COMBINER_SUM;
    case 4:
    case "COMBINER_WEIGHTED_TOP_K":
      return MultiValueCombiner.COMBINER_WEIGHTED_TOP_K;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MultiValueCombiner.UNRECOGNIZED;
  }
}

export function multiValueCombinerToJSON(object: MultiValueCombiner): string {
  switch (object) {
    case MultiValueCombiner.COMBINER_LOG_SUM_EXP:
      return "COMBINER_LOG_SUM_EXP";
    case MultiValueCombiner.COMBINER_MAX:
      return "COMBINER_MAX";
    case MultiValueCombiner.COMBINER_AVG:
      return "COMBINER_AVG";
    case MultiValueCombiner.COMBINER_SUM:
      return "COMBINER_SUM";
    case MultiValueCombiner.COMBINER_WEIGHTED_TOP_K:
      return "COMBINER_WEIGHTED_TOP_K";
    case MultiValueCombiner.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Query types */
export interface Query {
  term?: TermQuery | undefined;
  boolean?: BooleanQuery | undefined;
  boost?: BoostQuery | undefined;
  all?: AllQuery | undefined;
  sparseVector?: SparseVectorQuery | undefined;
  denseVector?: DenseVectorQuery | undefined;
  match?: MatchQuery | undefined;
}

/**
 * Sparse vector query for similarity search
 * Either provide (indices, values) directly, or provide text for server-side tokenization
 */
export interface SparseVectorQuery {
  field: string;
  /** Pre-computed token indices */
  indices: number[];
  /** Pre-computed token values */
  values: number[];
  /** Raw text (tokenized server-side if tokenizer configured) */
  text: string;
  /** How to combine scores for multi-value fields */
  combiner: MultiValueCombiner;
  /** Approximate search factor (1.0 = exact, 0.8 = ~20% faster) */
  heapFactor: number;
  /** Temperature for LogSumExp (default: 1.5) */
  combinerTemperature: number;
  /** K for WeightedTopK (default: 5) */
  combinerTopK: number;
  /** Decay for WeightedTopK (default: 0.7) */
  combinerDecay: number;
}

/** Dense vector query for similarity search */
export interface DenseVectorQuery {
  field: string;
  vector: number[];
  /** Number of clusters to probe (for IVF indexes) */
  nprobe: number;
  /** Re-ranking factor (multiplied by k) */
  rerankFactor: number;
  /** How to combine scores for multi-value fields */
  combiner: MultiValueCombiner;
  /** Temperature for LogSumExp (default: 1.5) */
  combinerTemperature: number;
  /** K for WeightedTopK (default: 5) */
  combinerTopK: number;
  /** Decay for WeightedTopK (default: 0.7) */
  combinerDecay: number;
}

export interface TermQuery {
  field: string;
  term: string;
}

export interface BooleanQuery {
  must: Query[];
  should: Query[];
  mustNot: Query[];
}

export interface BoostQuery {
  query: Query | undefined;
  boost: number;
}

export interface AllQuery {
}

/**
 * Full-text match query - tokenizes text server-side and searches as OR of tokens
 * Use this instead of TermQuery when searching with natural language text
 */
export interface MatchQuery {
  field: string;
  text: string;
}

/** L2 reranker: rerank L1 candidates by exact dense vector distance */
export interface Reranker {
  /** Dense vector field (must be stored) */
  field: string;
  /** Query vector */
  vector: number[];
  /** L1 candidate count (0 = 10x final limit) */
  limit: number;
  combiner: MultiValueCombiner;
  combinerTemperature: number;
  combinerTopK: number;
  combinerDecay: number;
  /** Matryoshka pre-filter dims (0 = disabled) */
  matryoshkaDims: number;
}

/** Fast-field filter for efficient document filtering */
export interface Filter {
  field: string;
  eqU64?: number | undefined;
  eqI64?: number | undefined;
  eqF64?: number | undefined;
  eqText?: string | undefined;
  range?: RangeFilter | undefined;
  inValues?: InFilter | undefined;
}

/** Numeric range filter (inclusive bounds) */
export interface RangeFilter {
  min?: number | undefined;
  max?: number | undefined;
}

/** Set membership filter */
export interface InFilter {
  textValues: string[];
  u64Values: number[];
  i64Values: number[];
}

/** Search request/response */
export interface SearchRequest {
  indexName: string;
  query: Query | undefined;
  limit: number;
  offset: number;
  fieldsToLoad: string[];
  /** Optional L2 reranker */
  reranker:
    | Reranker
    | undefined;
  /** Fast-field filters */
  filters: Filter[];
}

export interface SearchHit {
  docId: number;
  score: number;
  fields: { [key: string]: FieldValue };
  /** Per-ordinal scores for multi-value fields */
  ordinalScores: OrdinalScore[];
}

export interface SearchHit_FieldsEntry {
  key: string;
  value: FieldValue | undefined;
}

/** Score contribution from a specific ordinal in a multi-valued field */
export interface OrdinalScore {
  /** Which value in the multi-valued field (0-indexed) */
  ordinal: number;
  /** Score contribution from this ordinal */
  score: number;
}

export interface FieldValue {
  text?: string | undefined;
  u64?: number | undefined;
  i64?: number | undefined;
  f64?: number | undefined;
  bytesValue?: Uint8Array | undefined;
  sparseVector?: SparseVector | undefined;
  denseVector?:
    | DenseVector
    | undefined;
  /** JSON serialized as string */
  jsonValue?: string | undefined;
}

/** Sparse vector with term indices and weights */
export interface SparseVector {
  indices: number[];
  values: number[];
}

/** Dense vector (float32 values) */
export interface DenseVector {
  values: number[];
}

export interface SearchResponse {
  hits: SearchHit[];
  totalHits: number;
  tookMs: number;
  timings: SearchTimings | undefined;
}

/** Detailed timing breakdown for search phases (all values in microseconds) */
export interface SearchTimings {
  /** L1 retrieval (query scoring across segments) */
  searchUs: number;
  /** L2 reranking (dense vector rescoring) */
  rerankUs: number;
  /** Document field loading from store */
  loadUs: number;
  /** Wall-clock total (includes overhead) */
  totalUs: number;
}

/** Get document request/response */
export interface GetDocumentRequest {
  indexName: string;
  docId: number;
}

export interface GetDocumentResponse {
  fields: { [key: string]: FieldValue };
}

export interface GetDocumentResponse_FieldsEntry {
  key: string;
  value: FieldValue | undefined;
}

/** Index info request/response */
export interface GetIndexInfoRequest {
  indexName: string;
}

export interface GetIndexInfoResponse {
  indexName: string;
  numDocs: number;
  numSegments: number;
  /** Schema in SDL format */
  schema: string;
  /** Memory usage breakdown (if available) */
  memoryStats: MemoryStats | undefined;
}

/** Memory usage statistics */
export interface MemoryStats {
  /** Total estimated memory usage in bytes */
  totalBytes: number;
  /** Indexing buffer memory (pending documents not yet flushed) */
  indexingBuffer:
    | IndexingBufferStats
    | undefined;
  /** Segment reader memory (loaded for search) */
  segmentReader: SegmentReaderStats | undefined;
}

/** Indexing buffer memory breakdown */
export interface IndexingBufferStats {
  totalBytes: number;
  postingsBytes: number;
  sparseVectorsBytes: number;
  denseVectorsBytes: number;
  internerBytes: number;
  positionIndexBytes: number;
  pendingDocs: number;
  uniqueTerms: number;
}

/** Segment reader memory (search structures) */
export interface SegmentReaderStats {
  totalBytes: number;
  termDictCacheBytes: number;
  storeCacheBytes: number;
  sparseIndexBytes: number;
  denseIndexBytes: number;
  numSegmentsLoaded: number;
}

/** Create index request/response */
export interface CreateIndexRequest {
  indexName: string;
  /** Schema definition */
  schema: string;
}

export interface CreateIndexResponse {
  success: boolean;
}

/** Field entry for multi-value field support */
export interface FieldEntry {
  name: string;
  value: FieldValue | undefined;
}

/**
 * Named document for batch indexing
 * Uses repeated FieldEntry to support multi-value fields (same name, multiple values)
 */
export interface NamedDocument {
  fields: FieldEntry[];
}

/** Batch index documents request */
export interface BatchIndexDocumentsRequest {
  indexName: string;
  documents: NamedDocument[];
}

export interface BatchIndexDocumentsResponse {
  indexedCount: number;
  errorCount: number;
}

/** Index document request/response */
export interface IndexDocumentRequest {
  indexName: string;
  fields: FieldEntry[];
}

export interface IndexDocumentsResponse {
  indexedCount: number;
}

/** Commit request/response */
export interface CommitRequest {
  indexName: string;
}

export interface CommitResponse {
  success: boolean;
  numDocs: number;
}

/** Force merge request/response */
export interface ForceMergeRequest {
  indexName: string;
}

export interface ForceMergeResponse {
  success: boolean;
  numSegments: number;
}

/** Delete index request/response */
export interface DeleteIndexRequest {
  indexName: string;
}

export interface DeleteIndexResponse {
  success: boolean;
}

/** List indexes request/response */
export interface ListIndexesRequest {
}

export interface ListIndexesResponse {
  indexNames: string[];
}

/** Retrain vector index request/response */
export interface RetrainVectorIndexRequest {
  indexName: string;
}

export interface RetrainVectorIndexResponse {
  success: boolean;
}

function createBaseQuery(): Query {
  return {
    term: undefined,
    boolean: undefined,
    boost: undefined,
    all: undefined,
    sparseVector: undefined,
    denseVector: undefined,
    match: undefined,
  };
}

export const Query: MessageFns<Query> = {
  encode(message: Query, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.term !== undefined) {
      TermQuery.encode(message.term, writer.uint32(10).fork()).join();
    }
    if (message.boolean !== undefined) {
      BooleanQuery.encode(message.boolean, writer.uint32(18).fork()).join();
    }
    if (message.boost !== undefined) {
      BoostQuery.encode(message.boost, writer.uint32(26).fork()).join();
    }
    if (message.all !== undefined) {
      AllQuery.encode(message.all, writer.uint32(34).fork()).join();
    }
    if (message.sparseVector !== undefined) {
      SparseVectorQuery.encode(message.sparseVector, writer.uint32(42).fork()).join();
    }
    if (message.denseVector !== undefined) {
      DenseVectorQuery.encode(message.denseVector, writer.uint32(50).fork()).join();
    }
    if (message.match !== undefined) {
      MatchQuery.encode(message.match, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.term = TermQuery.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.boolean = BooleanQuery.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.boost = BoostQuery.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.all = AllQuery.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sparseVector = SparseVectorQuery.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.denseVector = DenseVectorQuery.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.match = MatchQuery.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query {
    return {
      term: isSet(object.term) ? TermQuery.fromJSON(object.term) : undefined,
      boolean: isSet(object.boolean) ? BooleanQuery.fromJSON(object.boolean) : undefined,
      boost: isSet(object.boost) ? BoostQuery.fromJSON(object.boost) : undefined,
      all: isSet(object.all) ? AllQuery.fromJSON(object.all) : undefined,
      sparseVector: isSet(object.sparseVector)
        ? SparseVectorQuery.fromJSON(object.sparseVector)
        : isSet(object.sparse_vector)
        ? SparseVectorQuery.fromJSON(object.sparse_vector)
        : undefined,
      denseVector: isSet(object.denseVector)
        ? DenseVectorQuery.fromJSON(object.denseVector)
        : isSet(object.dense_vector)
        ? DenseVectorQuery.fromJSON(object.dense_vector)
        : undefined,
      match: isSet(object.match) ? MatchQuery.fromJSON(object.match) : undefined,
    };
  },

  toJSON(message: Query): unknown {
    const obj: any = {};
    if (message.term !== undefined) {
      obj.term = TermQuery.toJSON(message.term);
    }
    if (message.boolean !== undefined) {
      obj.boolean = BooleanQuery.toJSON(message.boolean);
    }
    if (message.boost !== undefined) {
      obj.boost = BoostQuery.toJSON(message.boost);
    }
    if (message.all !== undefined) {
      obj.all = AllQuery.toJSON(message.all);
    }
    if (message.sparseVector !== undefined) {
      obj.sparseVector = SparseVectorQuery.toJSON(message.sparseVector);
    }
    if (message.denseVector !== undefined) {
      obj.denseVector = DenseVectorQuery.toJSON(message.denseVector);
    }
    if (message.match !== undefined) {
      obj.match = MatchQuery.toJSON(message.match);
    }
    return obj;
  },

  create(base?: DeepPartial<Query>): Query {
    return Query.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query>): Query {
    const message = createBaseQuery();
    message.term = (object.term !== undefined && object.term !== null) ? TermQuery.fromPartial(object.term) : undefined;
    message.boolean = (object.boolean !== undefined && object.boolean !== null)
      ? BooleanQuery.fromPartial(object.boolean)
      : undefined;
    message.boost = (object.boost !== undefined && object.boost !== null)
      ? BoostQuery.fromPartial(object.boost)
      : undefined;
    message.all = (object.all !== undefined && object.all !== null) ? AllQuery.fromPartial(object.all) : undefined;
    message.sparseVector = (object.sparseVector !== undefined && object.sparseVector !== null)
      ? SparseVectorQuery.fromPartial(object.sparseVector)
      : undefined;
    message.denseVector = (object.denseVector !== undefined && object.denseVector !== null)
      ? DenseVectorQuery.fromPartial(object.denseVector)
      : undefined;
    message.match = (object.match !== undefined && object.match !== null)
      ? MatchQuery.fromPartial(object.match)
      : undefined;
    return message;
  },
};

function createBaseSparseVectorQuery(): SparseVectorQuery {
  return {
    field: "",
    indices: [],
    values: [],
    text: "",
    combiner: 0,
    heapFactor: 0,
    combinerTemperature: 0,
    combinerTopK: 0,
    combinerDecay: 0,
  };
}

export const SparseVectorQuery: MessageFns<SparseVectorQuery> = {
  encode(message: SparseVectorQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    writer.uint32(18).fork();
    for (const v of message.indices) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.combiner !== 0) {
      writer.uint32(40).int32(message.combiner);
    }
    if (message.heapFactor !== 0) {
      writer.uint32(53).float(message.heapFactor);
    }
    if (message.combinerTemperature !== 0) {
      writer.uint32(61).float(message.combinerTemperature);
    }
    if (message.combinerTopK !== 0) {
      writer.uint32(64).uint32(message.combinerTopK);
    }
    if (message.combinerDecay !== 0) {
      writer.uint32(77).float(message.combinerDecay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparseVectorQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparseVectorQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.indices.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.indices.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 29) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.combiner = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.heapFactor = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.combinerTemperature = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.combinerTopK = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.combinerDecay = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparseVectorQuery {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      indices: globalThis.Array.isArray(object?.indices) ? object.indices.map((e: any) => globalThis.Number(e)) : [],
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      combiner: isSet(object.combiner) ? multiValueCombinerFromJSON(object.combiner) : 0,
      heapFactor: isSet(object.heapFactor)
        ? globalThis.Number(object.heapFactor)
        : isSet(object.heap_factor)
        ? globalThis.Number(object.heap_factor)
        : 0,
      combinerTemperature: isSet(object.combinerTemperature)
        ? globalThis.Number(object.combinerTemperature)
        : isSet(object.combiner_temperature)
        ? globalThis.Number(object.combiner_temperature)
        : 0,
      combinerTopK: isSet(object.combinerTopK)
        ? globalThis.Number(object.combinerTopK)
        : isSet(object.combiner_top_k)
        ? globalThis.Number(object.combiner_top_k)
        : 0,
      combinerDecay: isSet(object.combinerDecay)
        ? globalThis.Number(object.combinerDecay)
        : isSet(object.combiner_decay)
        ? globalThis.Number(object.combiner_decay)
        : 0,
    };
  },

  toJSON(message: SparseVectorQuery): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.indices?.length) {
      obj.indices = message.indices.map((e) => Math.round(e));
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.combiner !== 0) {
      obj.combiner = multiValueCombinerToJSON(message.combiner);
    }
    if (message.heapFactor !== 0) {
      obj.heapFactor = message.heapFactor;
    }
    if (message.combinerTemperature !== 0) {
      obj.combinerTemperature = message.combinerTemperature;
    }
    if (message.combinerTopK !== 0) {
      obj.combinerTopK = Math.round(message.combinerTopK);
    }
    if (message.combinerDecay !== 0) {
      obj.combinerDecay = message.combinerDecay;
    }
    return obj;
  },

  create(base?: DeepPartial<SparseVectorQuery>): SparseVectorQuery {
    return SparseVectorQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparseVectorQuery>): SparseVectorQuery {
    const message = createBaseSparseVectorQuery();
    message.field = object.field ?? "";
    message.indices = object.indices?.map((e) => e) || [];
    message.values = object.values?.map((e) => e) || [];
    message.text = object.text ?? "";
    message.combiner = object.combiner ?? 0;
    message.heapFactor = object.heapFactor ?? 0;
    message.combinerTemperature = object.combinerTemperature ?? 0;
    message.combinerTopK = object.combinerTopK ?? 0;
    message.combinerDecay = object.combinerDecay ?? 0;
    return message;
  },
};

function createBaseDenseVectorQuery(): DenseVectorQuery {
  return {
    field: "",
    vector: [],
    nprobe: 0,
    rerankFactor: 0,
    combiner: 0,
    combinerTemperature: 0,
    combinerTopK: 0,
    combinerDecay: 0,
  };
}

export const DenseVectorQuery: MessageFns<DenseVectorQuery> = {
  encode(message: DenseVectorQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    if (message.nprobe !== 0) {
      writer.uint32(24).uint32(message.nprobe);
    }
    if (message.rerankFactor !== 0) {
      writer.uint32(32).uint32(message.rerankFactor);
    }
    if (message.combiner !== 0) {
      writer.uint32(40).int32(message.combiner);
    }
    if (message.combinerTemperature !== 0) {
      writer.uint32(53).float(message.combinerTemperature);
    }
    if (message.combinerTopK !== 0) {
      writer.uint32(56).uint32(message.combinerTopK);
    }
    if (message.combinerDecay !== 0) {
      writer.uint32(69).float(message.combinerDecay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenseVectorQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenseVectorQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nprobe = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rerankFactor = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.combiner = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.combinerTemperature = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.combinerTopK = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.combinerDecay = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenseVectorQuery {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      nprobe: isSet(object.nprobe) ? globalThis.Number(object.nprobe) : 0,
      rerankFactor: isSet(object.rerankFactor)
        ? globalThis.Number(object.rerankFactor)
        : isSet(object.rerank_factor)
        ? globalThis.Number(object.rerank_factor)
        : 0,
      combiner: isSet(object.combiner) ? multiValueCombinerFromJSON(object.combiner) : 0,
      combinerTemperature: isSet(object.combinerTemperature)
        ? globalThis.Number(object.combinerTemperature)
        : isSet(object.combiner_temperature)
        ? globalThis.Number(object.combiner_temperature)
        : 0,
      combinerTopK: isSet(object.combinerTopK)
        ? globalThis.Number(object.combinerTopK)
        : isSet(object.combiner_top_k)
        ? globalThis.Number(object.combiner_top_k)
        : 0,
      combinerDecay: isSet(object.combinerDecay)
        ? globalThis.Number(object.combinerDecay)
        : isSet(object.combiner_decay)
        ? globalThis.Number(object.combiner_decay)
        : 0,
    };
  },

  toJSON(message: DenseVectorQuery): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.nprobe !== 0) {
      obj.nprobe = Math.round(message.nprobe);
    }
    if (message.rerankFactor !== 0) {
      obj.rerankFactor = Math.round(message.rerankFactor);
    }
    if (message.combiner !== 0) {
      obj.combiner = multiValueCombinerToJSON(message.combiner);
    }
    if (message.combinerTemperature !== 0) {
      obj.combinerTemperature = message.combinerTemperature;
    }
    if (message.combinerTopK !== 0) {
      obj.combinerTopK = Math.round(message.combinerTopK);
    }
    if (message.combinerDecay !== 0) {
      obj.combinerDecay = message.combinerDecay;
    }
    return obj;
  },

  create(base?: DeepPartial<DenseVectorQuery>): DenseVectorQuery {
    return DenseVectorQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DenseVectorQuery>): DenseVectorQuery {
    const message = createBaseDenseVectorQuery();
    message.field = object.field ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.nprobe = object.nprobe ?? 0;
    message.rerankFactor = object.rerankFactor ?? 0;
    message.combiner = object.combiner ?? 0;
    message.combinerTemperature = object.combinerTemperature ?? 0;
    message.combinerTopK = object.combinerTopK ?? 0;
    message.combinerDecay = object.combinerDecay ?? 0;
    return message;
  },
};

function createBaseTermQuery(): TermQuery {
  return { field: "", term: "" };
}

export const TermQuery: MessageFns<TermQuery> = {
  encode(message: TermQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.term !== "") {
      writer.uint32(18).string(message.term);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TermQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTermQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.term = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TermQuery {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      term: isSet(object.term) ? globalThis.String(object.term) : "",
    };
  },

  toJSON(message: TermQuery): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.term !== "") {
      obj.term = message.term;
    }
    return obj;
  },

  create(base?: DeepPartial<TermQuery>): TermQuery {
    return TermQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TermQuery>): TermQuery {
    const message = createBaseTermQuery();
    message.field = object.field ?? "";
    message.term = object.term ?? "";
    return message;
  },
};

function createBaseBooleanQuery(): BooleanQuery {
  return { must: [], should: [], mustNot: [] };
}

export const BooleanQuery: MessageFns<BooleanQuery> = {
  encode(message: BooleanQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.must) {
      Query.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.should) {
      Query.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.mustNot) {
      Query.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BooleanQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBooleanQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.must.push(Query.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.should.push(Query.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mustNot.push(Query.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BooleanQuery {
    return {
      must: globalThis.Array.isArray(object?.must) ? object.must.map((e: any) => Query.fromJSON(e)) : [],
      should: globalThis.Array.isArray(object?.should) ? object.should.map((e: any) => Query.fromJSON(e)) : [],
      mustNot: globalThis.Array.isArray(object?.mustNot)
        ? object.mustNot.map((e: any) => Query.fromJSON(e))
        : globalThis.Array.isArray(object?.must_not)
        ? object.must_not.map((e: any) => Query.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BooleanQuery): unknown {
    const obj: any = {};
    if (message.must?.length) {
      obj.must = message.must.map((e) => Query.toJSON(e));
    }
    if (message.should?.length) {
      obj.should = message.should.map((e) => Query.toJSON(e));
    }
    if (message.mustNot?.length) {
      obj.mustNot = message.mustNot.map((e) => Query.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BooleanQuery>): BooleanQuery {
    return BooleanQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BooleanQuery>): BooleanQuery {
    const message = createBaseBooleanQuery();
    message.must = object.must?.map((e) => Query.fromPartial(e)) || [];
    message.should = object.should?.map((e) => Query.fromPartial(e)) || [];
    message.mustNot = object.mustNot?.map((e) => Query.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoostQuery(): BoostQuery {
  return { query: undefined, boost: 0 };
}

export const BoostQuery: MessageFns<BoostQuery> = {
  encode(message: BoostQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(10).fork()).join();
    }
    if (message.boost !== 0) {
      writer.uint32(21).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoostQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoostQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.boost = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoostQuery {
    return {
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: BoostQuery): unknown {
    const obj: any = {};
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create(base?: DeepPartial<BoostQuery>): BoostQuery {
    return BoostQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoostQuery>): BoostQuery {
    const message = createBaseBoostQuery();
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBaseAllQuery(): AllQuery {
  return {};
}

export const AllQuery: MessageFns<AllQuery> = {
  encode(_: AllQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AllQuery {
    return {};
  },

  toJSON(_: AllQuery): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AllQuery>): AllQuery {
    return AllQuery.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AllQuery>): AllQuery {
    const message = createBaseAllQuery();
    return message;
  },
};

function createBaseMatchQuery(): MatchQuery {
  return { field: "", text: "" };
}

export const MatchQuery: MessageFns<MatchQuery> = {
  encode(message: MatchQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchQuery {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: MatchQuery): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<MatchQuery>): MatchQuery {
    return MatchQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchQuery>): MatchQuery {
    const message = createBaseMatchQuery();
    message.field = object.field ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseReranker(): Reranker {
  return {
    field: "",
    vector: [],
    limit: 0,
    combiner: 0,
    combinerTemperature: 0,
    combinerTopK: 0,
    combinerDecay: 0,
    matryoshkaDims: 0,
  };
}

export const Reranker: MessageFns<Reranker> = {
  encode(message: Reranker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    if (message.limit !== 0) {
      writer.uint32(24).uint32(message.limit);
    }
    if (message.combiner !== 0) {
      writer.uint32(32).int32(message.combiner);
    }
    if (message.combinerTemperature !== 0) {
      writer.uint32(45).float(message.combinerTemperature);
    }
    if (message.combinerTopK !== 0) {
      writer.uint32(48).uint32(message.combinerTopK);
    }
    if (message.combinerDecay !== 0) {
      writer.uint32(61).float(message.combinerDecay);
    }
    if (message.matryoshkaDims !== 0) {
      writer.uint32(64).uint32(message.matryoshkaDims);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reranker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReranker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.combiner = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.combinerTemperature = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.combinerTopK = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.combinerDecay = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.matryoshkaDims = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reranker {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      combiner: isSet(object.combiner) ? multiValueCombinerFromJSON(object.combiner) : 0,
      combinerTemperature: isSet(object.combinerTemperature)
        ? globalThis.Number(object.combinerTemperature)
        : isSet(object.combiner_temperature)
        ? globalThis.Number(object.combiner_temperature)
        : 0,
      combinerTopK: isSet(object.combinerTopK)
        ? globalThis.Number(object.combinerTopK)
        : isSet(object.combiner_top_k)
        ? globalThis.Number(object.combiner_top_k)
        : 0,
      combinerDecay: isSet(object.combinerDecay)
        ? globalThis.Number(object.combinerDecay)
        : isSet(object.combiner_decay)
        ? globalThis.Number(object.combiner_decay)
        : 0,
      matryoshkaDims: isSet(object.matryoshkaDims)
        ? globalThis.Number(object.matryoshkaDims)
        : isSet(object.matryoshka_dims)
        ? globalThis.Number(object.matryoshka_dims)
        : 0,
    };
  },

  toJSON(message: Reranker): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.combiner !== 0) {
      obj.combiner = multiValueCombinerToJSON(message.combiner);
    }
    if (message.combinerTemperature !== 0) {
      obj.combinerTemperature = message.combinerTemperature;
    }
    if (message.combinerTopK !== 0) {
      obj.combinerTopK = Math.round(message.combinerTopK);
    }
    if (message.combinerDecay !== 0) {
      obj.combinerDecay = message.combinerDecay;
    }
    if (message.matryoshkaDims !== 0) {
      obj.matryoshkaDims = Math.round(message.matryoshkaDims);
    }
    return obj;
  },

  create(base?: DeepPartial<Reranker>): Reranker {
    return Reranker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reranker>): Reranker {
    const message = createBaseReranker();
    message.field = object.field ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.combiner = object.combiner ?? 0;
    message.combinerTemperature = object.combinerTemperature ?? 0;
    message.combinerTopK = object.combinerTopK ?? 0;
    message.combinerDecay = object.combinerDecay ?? 0;
    message.matryoshkaDims = object.matryoshkaDims ?? 0;
    return message;
  },
};

function createBaseFilter(): Filter {
  return {
    field: "",
    eqU64: undefined,
    eqI64: undefined,
    eqF64: undefined,
    eqText: undefined,
    range: undefined,
    inValues: undefined,
  };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.eqU64 !== undefined) {
      writer.uint32(16).uint64(message.eqU64);
    }
    if (message.eqI64 !== undefined) {
      writer.uint32(24).int64(message.eqI64);
    }
    if (message.eqF64 !== undefined) {
      writer.uint32(33).double(message.eqF64);
    }
    if (message.eqText !== undefined) {
      writer.uint32(42).string(message.eqText);
    }
    if (message.range !== undefined) {
      RangeFilter.encode(message.range, writer.uint32(50).fork()).join();
    }
    if (message.inValues !== undefined) {
      InFilter.encode(message.inValues, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eqU64 = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eqI64 = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.eqF64 = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eqText = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.range = RangeFilter.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inValues = InFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      eqU64: isSet(object.eqU64)
        ? globalThis.Number(object.eqU64)
        : isSet(object.eq_u64)
        ? globalThis.Number(object.eq_u64)
        : undefined,
      eqI64: isSet(object.eqI64)
        ? globalThis.Number(object.eqI64)
        : isSet(object.eq_i64)
        ? globalThis.Number(object.eq_i64)
        : undefined,
      eqF64: isSet(object.eqF64)
        ? globalThis.Number(object.eqF64)
        : isSet(object.eq_f64)
        ? globalThis.Number(object.eq_f64)
        : undefined,
      eqText: isSet(object.eqText)
        ? globalThis.String(object.eqText)
        : isSet(object.eq_text)
        ? globalThis.String(object.eq_text)
        : undefined,
      range: isSet(object.range) ? RangeFilter.fromJSON(object.range) : undefined,
      inValues: isSet(object.inValues)
        ? InFilter.fromJSON(object.inValues)
        : isSet(object.in_values)
        ? InFilter.fromJSON(object.in_values)
        : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.eqU64 !== undefined) {
      obj.eqU64 = Math.round(message.eqU64);
    }
    if (message.eqI64 !== undefined) {
      obj.eqI64 = Math.round(message.eqI64);
    }
    if (message.eqF64 !== undefined) {
      obj.eqF64 = message.eqF64;
    }
    if (message.eqText !== undefined) {
      obj.eqText = message.eqText;
    }
    if (message.range !== undefined) {
      obj.range = RangeFilter.toJSON(message.range);
    }
    if (message.inValues !== undefined) {
      obj.inValues = InFilter.toJSON(message.inValues);
    }
    return obj;
  },

  create(base?: DeepPartial<Filter>): Filter {
    return Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter>): Filter {
    const message = createBaseFilter();
    message.field = object.field ?? "";
    message.eqU64 = object.eqU64 ?? undefined;
    message.eqI64 = object.eqI64 ?? undefined;
    message.eqF64 = object.eqF64 ?? undefined;
    message.eqText = object.eqText ?? undefined;
    message.range = (object.range !== undefined && object.range !== null)
      ? RangeFilter.fromPartial(object.range)
      : undefined;
    message.inValues = (object.inValues !== undefined && object.inValues !== null)
      ? InFilter.fromPartial(object.inValues)
      : undefined;
    return message;
  },
};

function createBaseRangeFilter(): RangeFilter {
  return { min: undefined, max: undefined };
}

export const RangeFilter: MessageFns<RangeFilter> = {
  encode(message: RangeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      writer.uint32(9).double(message.min);
    }
    if (message.max !== undefined) {
      writer.uint32(17).double(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RangeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRangeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.min = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.max = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RangeFilter {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : undefined,
      max: isSet(object.max) ? globalThis.Number(object.max) : undefined,
    };
  },

  toJSON(message: RangeFilter): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = message.min;
    }
    if (message.max !== undefined) {
      obj.max = message.max;
    }
    return obj;
  },

  create(base?: DeepPartial<RangeFilter>): RangeFilter {
    return RangeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RangeFilter>): RangeFilter {
    const message = createBaseRangeFilter();
    message.min = object.min ?? undefined;
    message.max = object.max ?? undefined;
    return message;
  },
};

function createBaseInFilter(): InFilter {
  return { textValues: [], u64Values: [], i64Values: [] };
}

export const InFilter: MessageFns<InFilter> = {
  encode(message: InFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.textValues) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.u64Values) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.i64Values) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.textValues.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.u64Values.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.u64Values.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.i64Values.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.i64Values.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InFilter {
    return {
      textValues: globalThis.Array.isArray(object?.textValues)
        ? object.textValues.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.text_values)
        ? object.text_values.map((e: any) => globalThis.String(e))
        : [],
      u64Values: globalThis.Array.isArray(object?.u64Values)
        ? object.u64Values.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.u64_values)
        ? object.u64_values.map((e: any) => globalThis.Number(e))
        : [],
      i64Values: globalThis.Array.isArray(object?.i64Values)
        ? object.i64Values.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.i64_values)
        ? object.i64_values.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: InFilter): unknown {
    const obj: any = {};
    if (message.textValues?.length) {
      obj.textValues = message.textValues;
    }
    if (message.u64Values?.length) {
      obj.u64Values = message.u64Values.map((e) => Math.round(e));
    }
    if (message.i64Values?.length) {
      obj.i64Values = message.i64Values.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InFilter>): InFilter {
    return InFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InFilter>): InFilter {
    const message = createBaseInFilter();
    message.textValues = object.textValues?.map((e) => e) || [];
    message.u64Values = object.u64Values?.map((e) => e) || [];
    message.i64Values = object.i64Values?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { indexName: "", query: undefined, limit: 0, offset: 0, fieldsToLoad: [], reranker: undefined, filters: [] };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(18).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).uint32(message.offset);
    }
    for (const v of message.fieldsToLoad) {
      writer.uint32(42).string(v!);
    }
    if (message.reranker !== undefined) {
      Reranker.encode(message.reranker, writer.uint32(50).fork()).join();
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fieldsToLoad.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reranker = Reranker.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
      query: isSet(object.query) ? Query.fromJSON(object.query) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      fieldsToLoad: globalThis.Array.isArray(object?.fieldsToLoad)
        ? object.fieldsToLoad.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.fields_to_load)
        ? object.fields_to_load.map((e: any) => globalThis.String(e))
        : [],
      reranker: isSet(object.reranker) ? Reranker.fromJSON(object.reranker) : undefined,
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    if (message.query !== undefined) {
      obj.query = Query.toJSON(message.query);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.fieldsToLoad?.length) {
      obj.fieldsToLoad = message.fieldsToLoad;
    }
    if (message.reranker !== undefined) {
      obj.reranker = Reranker.toJSON(message.reranker);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest>): SearchRequest {
    return SearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest>): SearchRequest {
    const message = createBaseSearchRequest();
    message.indexName = object.indexName ?? "";
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.fieldsToLoad = object.fieldsToLoad?.map((e) => e) || [];
    message.reranker = (object.reranker !== undefined && object.reranker !== null)
      ? Reranker.fromPartial(object.reranker)
      : undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchHit(): SearchHit {
  return { docId: 0, score: 0, fields: {}, ordinalScores: [] };
}

export const SearchHit: MessageFns<SearchHit> = {
  encode(message: SearchHit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.docId !== 0) {
      writer.uint32(8).uint32(message.docId);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    globalThis.Object.entries(message.fields).forEach(([key, value]: [string, FieldValue]) => {
      SearchHit_FieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.ordinalScores) {
      OrdinalScore.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.docId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SearchHit_FieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fields[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ordinalScores.push(OrdinalScore.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHit {
    return {
      docId: isSet(object.docId)
        ? globalThis.Number(object.docId)
        : isSet(object.doc_id)
        ? globalThis.Number(object.doc_id)
        : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      fields: isObject(object.fields)
        ? (globalThis.Object.entries(object.fields) as [string, any][]).reduce(
          (acc: { [key: string]: FieldValue }, [key, value]: [string, any]) => {
            acc[key] = FieldValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      ordinalScores: globalThis.Array.isArray(object?.ordinalScores)
        ? object.ordinalScores.map((e: any) => OrdinalScore.fromJSON(e))
        : globalThis.Array.isArray(object?.ordinal_scores)
        ? object.ordinal_scores.map((e: any) => OrdinalScore.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchHit): unknown {
    const obj: any = {};
    if (message.docId !== 0) {
      obj.docId = Math.round(message.docId);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.fields) {
      const entries = globalThis.Object.entries(message.fields) as [string, FieldValue][];
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = FieldValue.toJSON(v);
        });
      }
    }
    if (message.ordinalScores?.length) {
      obj.ordinalScores = message.ordinalScores.map((e) => OrdinalScore.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchHit>): SearchHit {
    return SearchHit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchHit>): SearchHit {
    const message = createBaseSearchHit();
    message.docId = object.docId ?? 0;
    message.score = object.score ?? 0;
    message.fields = (globalThis.Object.entries(object.fields ?? {}) as [string, FieldValue][]).reduce(
      (acc: { [key: string]: FieldValue }, [key, value]: [string, FieldValue]) => {
        if (value !== undefined) {
          acc[key] = FieldValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.ordinalScores = object.ordinalScores?.map((e) => OrdinalScore.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchHit_FieldsEntry(): SearchHit_FieldsEntry {
  return { key: "", value: undefined };
}

export const SearchHit_FieldsEntry: MessageFns<SearchHit_FieldsEntry> = {
  encode(message: SearchHit_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FieldValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHit_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHit_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FieldValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHit_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FieldValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SearchHit_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FieldValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchHit_FieldsEntry>): SearchHit_FieldsEntry {
    return SearchHit_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchHit_FieldsEntry>): SearchHit_FieldsEntry {
    const message = createBaseSearchHit_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOrdinalScore(): OrdinalScore {
  return { ordinal: 0, score: 0 };
}

export const OrdinalScore: MessageFns<OrdinalScore> = {
  encode(message: OrdinalScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ordinal !== 0) {
      writer.uint32(8).uint32(message.ordinal);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrdinalScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdinalScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ordinal = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrdinalScore {
    return {
      ordinal: isSet(object.ordinal) ? globalThis.Number(object.ordinal) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: OrdinalScore): unknown {
    const obj: any = {};
    if (message.ordinal !== 0) {
      obj.ordinal = Math.round(message.ordinal);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<OrdinalScore>): OrdinalScore {
    return OrdinalScore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrdinalScore>): OrdinalScore {
    const message = createBaseOrdinalScore();
    message.ordinal = object.ordinal ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseFieldValue(): FieldValue {
  return {
    text: undefined,
    u64: undefined,
    i64: undefined,
    f64: undefined,
    bytesValue: undefined,
    sparseVector: undefined,
    denseVector: undefined,
    jsonValue: undefined,
  };
}

export const FieldValue: MessageFns<FieldValue> = {
  encode(message: FieldValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(10).string(message.text);
    }
    if (message.u64 !== undefined) {
      writer.uint32(16).uint64(message.u64);
    }
    if (message.i64 !== undefined) {
      writer.uint32(24).int64(message.i64);
    }
    if (message.f64 !== undefined) {
      writer.uint32(33).double(message.f64);
    }
    if (message.bytesValue !== undefined) {
      writer.uint32(42).bytes(message.bytesValue);
    }
    if (message.sparseVector !== undefined) {
      SparseVector.encode(message.sparseVector, writer.uint32(50).fork()).join();
    }
    if (message.denseVector !== undefined) {
      DenseVector.encode(message.denseVector, writer.uint32(58).fork()).join();
    }
    if (message.jsonValue !== undefined) {
      writer.uint32(66).string(message.jsonValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.u64 = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.i64 = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.f64 = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bytesValue = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sparseVector = SparseVector.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.denseVector = DenseVector.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.jsonValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldValue {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      u64: isSet(object.u64) ? globalThis.Number(object.u64) : undefined,
      i64: isSet(object.i64) ? globalThis.Number(object.i64) : undefined,
      f64: isSet(object.f64) ? globalThis.Number(object.f64) : undefined,
      bytesValue: isSet(object.bytesValue)
        ? bytesFromBase64(object.bytesValue)
        : isSet(object.bytes_value)
        ? bytesFromBase64(object.bytes_value)
        : undefined,
      sparseVector: isSet(object.sparseVector)
        ? SparseVector.fromJSON(object.sparseVector)
        : isSet(object.sparse_vector)
        ? SparseVector.fromJSON(object.sparse_vector)
        : undefined,
      denseVector: isSet(object.denseVector)
        ? DenseVector.fromJSON(object.denseVector)
        : isSet(object.dense_vector)
        ? DenseVector.fromJSON(object.dense_vector)
        : undefined,
      jsonValue: isSet(object.jsonValue)
        ? globalThis.String(object.jsonValue)
        : isSet(object.json_value)
        ? globalThis.String(object.json_value)
        : undefined,
    };
  },

  toJSON(message: FieldValue): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.u64 !== undefined) {
      obj.u64 = Math.round(message.u64);
    }
    if (message.i64 !== undefined) {
      obj.i64 = Math.round(message.i64);
    }
    if (message.f64 !== undefined) {
      obj.f64 = message.f64;
    }
    if (message.bytesValue !== undefined) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.sparseVector !== undefined) {
      obj.sparseVector = SparseVector.toJSON(message.sparseVector);
    }
    if (message.denseVector !== undefined) {
      obj.denseVector = DenseVector.toJSON(message.denseVector);
    }
    if (message.jsonValue !== undefined) {
      obj.jsonValue = message.jsonValue;
    }
    return obj;
  },

  create(base?: DeepPartial<FieldValue>): FieldValue {
    return FieldValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldValue>): FieldValue {
    const message = createBaseFieldValue();
    message.text = object.text ?? undefined;
    message.u64 = object.u64 ?? undefined;
    message.i64 = object.i64 ?? undefined;
    message.f64 = object.f64 ?? undefined;
    message.bytesValue = object.bytesValue ?? undefined;
    message.sparseVector = (object.sparseVector !== undefined && object.sparseVector !== null)
      ? SparseVector.fromPartial(object.sparseVector)
      : undefined;
    message.denseVector = (object.denseVector !== undefined && object.denseVector !== null)
      ? DenseVector.fromPartial(object.denseVector)
      : undefined;
    message.jsonValue = object.jsonValue ?? undefined;
    return message;
  },
};

function createBaseSparseVector(): SparseVector {
  return { indices: [], values: [] };
}

export const SparseVector: MessageFns<SparseVector> = {
  encode(message: SparseVector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.indices) {
      writer.uint32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SparseVector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSparseVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.indices.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.indices.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SparseVector {
    return {
      indices: globalThis.Array.isArray(object?.indices) ? object.indices.map((e: any) => globalThis.Number(e)) : [],
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SparseVector): unknown {
    const obj: any = {};
    if (message.indices?.length) {
      obj.indices = message.indices.map((e) => Math.round(e));
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<SparseVector>): SparseVector {
    return SparseVector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SparseVector>): SparseVector {
    const message = createBaseSparseVector();
    message.indices = object.indices?.map((e) => e) || [];
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseDenseVector(): DenseVector {
  return { values: [] };
}

export const DenseVector: MessageFns<DenseVector> = {
  encode(message: DenseVector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenseVector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenseVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenseVector {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DenseVector): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<DenseVector>): DenseVector {
    return DenseVector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DenseVector>): DenseVector {
    const message = createBaseDenseVector();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { hits: [], totalHits: 0, tookMs: 0, timings: undefined };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hits) {
      SearchHit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalHits !== 0) {
      writer.uint32(16).uint32(message.totalHits);
    }
    if (message.tookMs !== 0) {
      writer.uint32(24).uint64(message.tookMs);
    }
    if (message.timings !== undefined) {
      SearchTimings.encode(message.timings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hits.push(SearchHit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalHits = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tookMs = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timings = SearchTimings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      hits: globalThis.Array.isArray(object?.hits) ? object.hits.map((e: any) => SearchHit.fromJSON(e)) : [],
      totalHits: isSet(object.totalHits)
        ? globalThis.Number(object.totalHits)
        : isSet(object.total_hits)
        ? globalThis.Number(object.total_hits)
        : 0,
      tookMs: isSet(object.tookMs)
        ? globalThis.Number(object.tookMs)
        : isSet(object.took_ms)
        ? globalThis.Number(object.took_ms)
        : 0,
      timings: isSet(object.timings) ? SearchTimings.fromJSON(object.timings) : undefined,
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.hits?.length) {
      obj.hits = message.hits.map((e) => SearchHit.toJSON(e));
    }
    if (message.totalHits !== 0) {
      obj.totalHits = Math.round(message.totalHits);
    }
    if (message.tookMs !== 0) {
      obj.tookMs = Math.round(message.tookMs);
    }
    if (message.timings !== undefined) {
      obj.timings = SearchTimings.toJSON(message.timings);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse>): SearchResponse {
    return SearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse>): SearchResponse {
    const message = createBaseSearchResponse();
    message.hits = object.hits?.map((e) => SearchHit.fromPartial(e)) || [];
    message.totalHits = object.totalHits ?? 0;
    message.tookMs = object.tookMs ?? 0;
    message.timings = (object.timings !== undefined && object.timings !== null)
      ? SearchTimings.fromPartial(object.timings)
      : undefined;
    return message;
  },
};

function createBaseSearchTimings(): SearchTimings {
  return { searchUs: 0, rerankUs: 0, loadUs: 0, totalUs: 0 };
}

export const SearchTimings: MessageFns<SearchTimings> = {
  encode(message: SearchTimings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchUs !== 0) {
      writer.uint32(8).uint64(message.searchUs);
    }
    if (message.rerankUs !== 0) {
      writer.uint32(16).uint64(message.rerankUs);
    }
    if (message.loadUs !== 0) {
      writer.uint32(24).uint64(message.loadUs);
    }
    if (message.totalUs !== 0) {
      writer.uint32(32).uint64(message.totalUs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTimings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTimings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.searchUs = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rerankUs = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.loadUs = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalUs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTimings {
    return {
      searchUs: isSet(object.searchUs)
        ? globalThis.Number(object.searchUs)
        : isSet(object.search_us)
        ? globalThis.Number(object.search_us)
        : 0,
      rerankUs: isSet(object.rerankUs)
        ? globalThis.Number(object.rerankUs)
        : isSet(object.rerank_us)
        ? globalThis.Number(object.rerank_us)
        : 0,
      loadUs: isSet(object.loadUs)
        ? globalThis.Number(object.loadUs)
        : isSet(object.load_us)
        ? globalThis.Number(object.load_us)
        : 0,
      totalUs: isSet(object.totalUs)
        ? globalThis.Number(object.totalUs)
        : isSet(object.total_us)
        ? globalThis.Number(object.total_us)
        : 0,
    };
  },

  toJSON(message: SearchTimings): unknown {
    const obj: any = {};
    if (message.searchUs !== 0) {
      obj.searchUs = Math.round(message.searchUs);
    }
    if (message.rerankUs !== 0) {
      obj.rerankUs = Math.round(message.rerankUs);
    }
    if (message.loadUs !== 0) {
      obj.loadUs = Math.round(message.loadUs);
    }
    if (message.totalUs !== 0) {
      obj.totalUs = Math.round(message.totalUs);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTimings>): SearchTimings {
    return SearchTimings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTimings>): SearchTimings {
    const message = createBaseSearchTimings();
    message.searchUs = object.searchUs ?? 0;
    message.rerankUs = object.rerankUs ?? 0;
    message.loadUs = object.loadUs ?? 0;
    message.totalUs = object.totalUs ?? 0;
    return message;
  },
};

function createBaseGetDocumentRequest(): GetDocumentRequest {
  return { indexName: "", docId: 0 };
}

export const GetDocumentRequest: MessageFns<GetDocumentRequest> = {
  encode(message: GetDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    if (message.docId !== 0) {
      writer.uint32(16).uint32(message.docId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.docId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
      docId: isSet(object.docId)
        ? globalThis.Number(object.docId)
        : isSet(object.doc_id)
        ? globalThis.Number(object.doc_id)
        : 0,
    };
  },

  toJSON(message: GetDocumentRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    if (message.docId !== 0) {
      obj.docId = Math.round(message.docId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDocumentRequest>): GetDocumentRequest {
    return GetDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDocumentRequest>): GetDocumentRequest {
    const message = createBaseGetDocumentRequest();
    message.indexName = object.indexName ?? "";
    message.docId = object.docId ?? 0;
    return message;
  },
};

function createBaseGetDocumentResponse(): GetDocumentResponse {
  return { fields: {} };
}

export const GetDocumentResponse: MessageFns<GetDocumentResponse> = {
  encode(message: GetDocumentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.fields).forEach(([key, value]: [string, FieldValue]) => {
      GetDocumentResponse_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocumentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetDocumentResponse_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentResponse {
    return {
      fields: isObject(object.fields)
        ? (globalThis.Object.entries(object.fields) as [string, any][]).reduce(
          (acc: { [key: string]: FieldValue }, [key, value]: [string, any]) => {
            acc[key] = FieldValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetDocumentResponse): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = globalThis.Object.entries(message.fields) as [string, FieldValue][];
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = FieldValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetDocumentResponse>): GetDocumentResponse {
    return GetDocumentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDocumentResponse>): GetDocumentResponse {
    const message = createBaseGetDocumentResponse();
    message.fields = (globalThis.Object.entries(object.fields ?? {}) as [string, FieldValue][]).reduce(
      (acc: { [key: string]: FieldValue }, [key, value]: [string, FieldValue]) => {
        if (value !== undefined) {
          acc[key] = FieldValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetDocumentResponse_FieldsEntry(): GetDocumentResponse_FieldsEntry {
  return { key: "", value: undefined };
}

export const GetDocumentResponse_FieldsEntry: MessageFns<GetDocumentResponse_FieldsEntry> = {
  encode(message: GetDocumentResponse_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FieldValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocumentResponse_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentResponse_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FieldValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentResponse_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FieldValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetDocumentResponse_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FieldValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDocumentResponse_FieldsEntry>): GetDocumentResponse_FieldsEntry {
    return GetDocumentResponse_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDocumentResponse_FieldsEntry>): GetDocumentResponse_FieldsEntry {
    const message = createBaseGetDocumentResponse_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetIndexInfoRequest(): GetIndexInfoRequest {
  return { indexName: "" };
}

export const GetIndexInfoRequest: MessageFns<GetIndexInfoRequest> = {
  encode(message: GetIndexInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexInfoRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
    };
  },

  toJSON(message: GetIndexInfoRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIndexInfoRequest>): GetIndexInfoRequest {
    return GetIndexInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIndexInfoRequest>): GetIndexInfoRequest {
    const message = createBaseGetIndexInfoRequest();
    message.indexName = object.indexName ?? "";
    return message;
  },
};

function createBaseGetIndexInfoResponse(): GetIndexInfoResponse {
  return { indexName: "", numDocs: 0, numSegments: 0, schema: "", memoryStats: undefined };
}

export const GetIndexInfoResponse: MessageFns<GetIndexInfoResponse> = {
  encode(message: GetIndexInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    if (message.numDocs !== 0) {
      writer.uint32(16).uint32(message.numDocs);
    }
    if (message.numSegments !== 0) {
      writer.uint32(24).uint32(message.numSegments);
    }
    if (message.schema !== "") {
      writer.uint32(34).string(message.schema);
    }
    if (message.memoryStats !== undefined) {
      MemoryStats.encode(message.memoryStats, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numDocs = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numSegments = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.memoryStats = MemoryStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexInfoResponse {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
      numDocs: isSet(object.numDocs)
        ? globalThis.Number(object.numDocs)
        : isSet(object.num_docs)
        ? globalThis.Number(object.num_docs)
        : 0,
      numSegments: isSet(object.numSegments)
        ? globalThis.Number(object.numSegments)
        : isSet(object.num_segments)
        ? globalThis.Number(object.num_segments)
        : 0,
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      memoryStats: isSet(object.memoryStats)
        ? MemoryStats.fromJSON(object.memoryStats)
        : isSet(object.memory_stats)
        ? MemoryStats.fromJSON(object.memory_stats)
        : undefined,
    };
  },

  toJSON(message: GetIndexInfoResponse): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    if (message.numDocs !== 0) {
      obj.numDocs = Math.round(message.numDocs);
    }
    if (message.numSegments !== 0) {
      obj.numSegments = Math.round(message.numSegments);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.memoryStats !== undefined) {
      obj.memoryStats = MemoryStats.toJSON(message.memoryStats);
    }
    return obj;
  },

  create(base?: DeepPartial<GetIndexInfoResponse>): GetIndexInfoResponse {
    return GetIndexInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIndexInfoResponse>): GetIndexInfoResponse {
    const message = createBaseGetIndexInfoResponse();
    message.indexName = object.indexName ?? "";
    message.numDocs = object.numDocs ?? 0;
    message.numSegments = object.numSegments ?? 0;
    message.schema = object.schema ?? "";
    message.memoryStats = (object.memoryStats !== undefined && object.memoryStats !== null)
      ? MemoryStats.fromPartial(object.memoryStats)
      : undefined;
    return message;
  },
};

function createBaseMemoryStats(): MemoryStats {
  return { totalBytes: 0, indexingBuffer: undefined, segmentReader: undefined };
}

export const MemoryStats: MessageFns<MemoryStats> = {
  encode(message: MemoryStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalBytes !== 0) {
      writer.uint32(8).uint64(message.totalBytes);
    }
    if (message.indexingBuffer !== undefined) {
      IndexingBufferStats.encode(message.indexingBuffer, writer.uint32(18).fork()).join();
    }
    if (message.segmentReader !== undefined) {
      SegmentReaderStats.encode(message.segmentReader, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalBytes = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indexingBuffer = IndexingBufferStats.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.segmentReader = SegmentReaderStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryStats {
    return {
      totalBytes: isSet(object.totalBytes)
        ? globalThis.Number(object.totalBytes)
        : isSet(object.total_bytes)
        ? globalThis.Number(object.total_bytes)
        : 0,
      indexingBuffer: isSet(object.indexingBuffer)
        ? IndexingBufferStats.fromJSON(object.indexingBuffer)
        : isSet(object.indexing_buffer)
        ? IndexingBufferStats.fromJSON(object.indexing_buffer)
        : undefined,
      segmentReader: isSet(object.segmentReader)
        ? SegmentReaderStats.fromJSON(object.segmentReader)
        : isSet(object.segment_reader)
        ? SegmentReaderStats.fromJSON(object.segment_reader)
        : undefined,
    };
  },

  toJSON(message: MemoryStats): unknown {
    const obj: any = {};
    if (message.totalBytes !== 0) {
      obj.totalBytes = Math.round(message.totalBytes);
    }
    if (message.indexingBuffer !== undefined) {
      obj.indexingBuffer = IndexingBufferStats.toJSON(message.indexingBuffer);
    }
    if (message.segmentReader !== undefined) {
      obj.segmentReader = SegmentReaderStats.toJSON(message.segmentReader);
    }
    return obj;
  },

  create(base?: DeepPartial<MemoryStats>): MemoryStats {
    return MemoryStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MemoryStats>): MemoryStats {
    const message = createBaseMemoryStats();
    message.totalBytes = object.totalBytes ?? 0;
    message.indexingBuffer = (object.indexingBuffer !== undefined && object.indexingBuffer !== null)
      ? IndexingBufferStats.fromPartial(object.indexingBuffer)
      : undefined;
    message.segmentReader = (object.segmentReader !== undefined && object.segmentReader !== null)
      ? SegmentReaderStats.fromPartial(object.segmentReader)
      : undefined;
    return message;
  },
};

function createBaseIndexingBufferStats(): IndexingBufferStats {
  return {
    totalBytes: 0,
    postingsBytes: 0,
    sparseVectorsBytes: 0,
    denseVectorsBytes: 0,
    internerBytes: 0,
    positionIndexBytes: 0,
    pendingDocs: 0,
    uniqueTerms: 0,
  };
}

export const IndexingBufferStats: MessageFns<IndexingBufferStats> = {
  encode(message: IndexingBufferStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalBytes !== 0) {
      writer.uint32(8).uint64(message.totalBytes);
    }
    if (message.postingsBytes !== 0) {
      writer.uint32(16).uint64(message.postingsBytes);
    }
    if (message.sparseVectorsBytes !== 0) {
      writer.uint32(24).uint64(message.sparseVectorsBytes);
    }
    if (message.denseVectorsBytes !== 0) {
      writer.uint32(32).uint64(message.denseVectorsBytes);
    }
    if (message.internerBytes !== 0) {
      writer.uint32(40).uint64(message.internerBytes);
    }
    if (message.positionIndexBytes !== 0) {
      writer.uint32(48).uint64(message.positionIndexBytes);
    }
    if (message.pendingDocs !== 0) {
      writer.uint32(56).uint32(message.pendingDocs);
    }
    if (message.uniqueTerms !== 0) {
      writer.uint32(64).uint32(message.uniqueTerms);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexingBufferStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexingBufferStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalBytes = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.postingsBytes = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sparseVectorsBytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.denseVectorsBytes = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.internerBytes = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.positionIndexBytes = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pendingDocs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uniqueTerms = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexingBufferStats {
    return {
      totalBytes: isSet(object.totalBytes)
        ? globalThis.Number(object.totalBytes)
        : isSet(object.total_bytes)
        ? globalThis.Number(object.total_bytes)
        : 0,
      postingsBytes: isSet(object.postingsBytes)
        ? globalThis.Number(object.postingsBytes)
        : isSet(object.postings_bytes)
        ? globalThis.Number(object.postings_bytes)
        : 0,
      sparseVectorsBytes: isSet(object.sparseVectorsBytes)
        ? globalThis.Number(object.sparseVectorsBytes)
        : isSet(object.sparse_vectors_bytes)
        ? globalThis.Number(object.sparse_vectors_bytes)
        : 0,
      denseVectorsBytes: isSet(object.denseVectorsBytes)
        ? globalThis.Number(object.denseVectorsBytes)
        : isSet(object.dense_vectors_bytes)
        ? globalThis.Number(object.dense_vectors_bytes)
        : 0,
      internerBytes: isSet(object.internerBytes)
        ? globalThis.Number(object.internerBytes)
        : isSet(object.interner_bytes)
        ? globalThis.Number(object.interner_bytes)
        : 0,
      positionIndexBytes: isSet(object.positionIndexBytes)
        ? globalThis.Number(object.positionIndexBytes)
        : isSet(object.position_index_bytes)
        ? globalThis.Number(object.position_index_bytes)
        : 0,
      pendingDocs: isSet(object.pendingDocs)
        ? globalThis.Number(object.pendingDocs)
        : isSet(object.pending_docs)
        ? globalThis.Number(object.pending_docs)
        : 0,
      uniqueTerms: isSet(object.uniqueTerms)
        ? globalThis.Number(object.uniqueTerms)
        : isSet(object.unique_terms)
        ? globalThis.Number(object.unique_terms)
        : 0,
    };
  },

  toJSON(message: IndexingBufferStats): unknown {
    const obj: any = {};
    if (message.totalBytes !== 0) {
      obj.totalBytes = Math.round(message.totalBytes);
    }
    if (message.postingsBytes !== 0) {
      obj.postingsBytes = Math.round(message.postingsBytes);
    }
    if (message.sparseVectorsBytes !== 0) {
      obj.sparseVectorsBytes = Math.round(message.sparseVectorsBytes);
    }
    if (message.denseVectorsBytes !== 0) {
      obj.denseVectorsBytes = Math.round(message.denseVectorsBytes);
    }
    if (message.internerBytes !== 0) {
      obj.internerBytes = Math.round(message.internerBytes);
    }
    if (message.positionIndexBytes !== 0) {
      obj.positionIndexBytes = Math.round(message.positionIndexBytes);
    }
    if (message.pendingDocs !== 0) {
      obj.pendingDocs = Math.round(message.pendingDocs);
    }
    if (message.uniqueTerms !== 0) {
      obj.uniqueTerms = Math.round(message.uniqueTerms);
    }
    return obj;
  },

  create(base?: DeepPartial<IndexingBufferStats>): IndexingBufferStats {
    return IndexingBufferStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexingBufferStats>): IndexingBufferStats {
    const message = createBaseIndexingBufferStats();
    message.totalBytes = object.totalBytes ?? 0;
    message.postingsBytes = object.postingsBytes ?? 0;
    message.sparseVectorsBytes = object.sparseVectorsBytes ?? 0;
    message.denseVectorsBytes = object.denseVectorsBytes ?? 0;
    message.internerBytes = object.internerBytes ?? 0;
    message.positionIndexBytes = object.positionIndexBytes ?? 0;
    message.pendingDocs = object.pendingDocs ?? 0;
    message.uniqueTerms = object.uniqueTerms ?? 0;
    return message;
  },
};

function createBaseSegmentReaderStats(): SegmentReaderStats {
  return {
    totalBytes: 0,
    termDictCacheBytes: 0,
    storeCacheBytes: 0,
    sparseIndexBytes: 0,
    denseIndexBytes: 0,
    numSegmentsLoaded: 0,
  };
}

export const SegmentReaderStats: MessageFns<SegmentReaderStats> = {
  encode(message: SegmentReaderStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalBytes !== 0) {
      writer.uint32(8).uint64(message.totalBytes);
    }
    if (message.termDictCacheBytes !== 0) {
      writer.uint32(16).uint64(message.termDictCacheBytes);
    }
    if (message.storeCacheBytes !== 0) {
      writer.uint32(24).uint64(message.storeCacheBytes);
    }
    if (message.sparseIndexBytes !== 0) {
      writer.uint32(32).uint64(message.sparseIndexBytes);
    }
    if (message.denseIndexBytes !== 0) {
      writer.uint32(40).uint64(message.denseIndexBytes);
    }
    if (message.numSegmentsLoaded !== 0) {
      writer.uint32(48).uint32(message.numSegmentsLoaded);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentReaderStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentReaderStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalBytes = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.termDictCacheBytes = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.storeCacheBytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sparseIndexBytes = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.denseIndexBytes = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numSegmentsLoaded = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentReaderStats {
    return {
      totalBytes: isSet(object.totalBytes)
        ? globalThis.Number(object.totalBytes)
        : isSet(object.total_bytes)
        ? globalThis.Number(object.total_bytes)
        : 0,
      termDictCacheBytes: isSet(object.termDictCacheBytes)
        ? globalThis.Number(object.termDictCacheBytes)
        : isSet(object.term_dict_cache_bytes)
        ? globalThis.Number(object.term_dict_cache_bytes)
        : 0,
      storeCacheBytes: isSet(object.storeCacheBytes)
        ? globalThis.Number(object.storeCacheBytes)
        : isSet(object.store_cache_bytes)
        ? globalThis.Number(object.store_cache_bytes)
        : 0,
      sparseIndexBytes: isSet(object.sparseIndexBytes)
        ? globalThis.Number(object.sparseIndexBytes)
        : isSet(object.sparse_index_bytes)
        ? globalThis.Number(object.sparse_index_bytes)
        : 0,
      denseIndexBytes: isSet(object.denseIndexBytes)
        ? globalThis.Number(object.denseIndexBytes)
        : isSet(object.dense_index_bytes)
        ? globalThis.Number(object.dense_index_bytes)
        : 0,
      numSegmentsLoaded: isSet(object.numSegmentsLoaded)
        ? globalThis.Number(object.numSegmentsLoaded)
        : isSet(object.num_segments_loaded)
        ? globalThis.Number(object.num_segments_loaded)
        : 0,
    };
  },

  toJSON(message: SegmentReaderStats): unknown {
    const obj: any = {};
    if (message.totalBytes !== 0) {
      obj.totalBytes = Math.round(message.totalBytes);
    }
    if (message.termDictCacheBytes !== 0) {
      obj.termDictCacheBytes = Math.round(message.termDictCacheBytes);
    }
    if (message.storeCacheBytes !== 0) {
      obj.storeCacheBytes = Math.round(message.storeCacheBytes);
    }
    if (message.sparseIndexBytes !== 0) {
      obj.sparseIndexBytes = Math.round(message.sparseIndexBytes);
    }
    if (message.denseIndexBytes !== 0) {
      obj.denseIndexBytes = Math.round(message.denseIndexBytes);
    }
    if (message.numSegmentsLoaded !== 0) {
      obj.numSegmentsLoaded = Math.round(message.numSegmentsLoaded);
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentReaderStats>): SegmentReaderStats {
    return SegmentReaderStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentReaderStats>): SegmentReaderStats {
    const message = createBaseSegmentReaderStats();
    message.totalBytes = object.totalBytes ?? 0;
    message.termDictCacheBytes = object.termDictCacheBytes ?? 0;
    message.storeCacheBytes = object.storeCacheBytes ?? 0;
    message.sparseIndexBytes = object.sparseIndexBytes ?? 0;
    message.denseIndexBytes = object.denseIndexBytes ?? 0;
    message.numSegmentsLoaded = object.numSegmentsLoaded ?? 0;
    return message;
  },
};

function createBaseCreateIndexRequest(): CreateIndexRequest {
  return { indexName: "", schema: "" };
}

export const CreateIndexRequest: MessageFns<CreateIndexRequest> = {
  encode(message: CreateIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
    };
  },

  toJSON(message: CreateIndexRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    return CreateIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    const message = createBaseCreateIndexRequest();
    message.indexName = object.indexName ?? "";
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseCreateIndexResponse(): CreateIndexResponse {
  return { success: false };
}

export const CreateIndexResponse: MessageFns<CreateIndexResponse> = {
  encode(message: CreateIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateIndexResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexResponse>): CreateIndexResponse {
    return CreateIndexResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexResponse>): CreateIndexResponse {
    const message = createBaseCreateIndexResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseFieldEntry(): FieldEntry {
  return { name: "", value: undefined };
}

export const FieldEntry: MessageFns<FieldEntry> = {
  encode(message: FieldEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      FieldValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FieldValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldEntry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? FieldValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FieldEntry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = FieldValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<FieldEntry>): FieldEntry {
    return FieldEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldEntry>): FieldEntry {
    const message = createBaseFieldEntry();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNamedDocument(): NamedDocument {
  return { fields: [] };
}

export const NamedDocument: MessageFns<NamedDocument> = {
  encode(message: NamedDocument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      FieldEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedDocument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fields.push(FieldEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedDocument {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => FieldEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: NamedDocument): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => FieldEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NamedDocument>): NamedDocument {
    return NamedDocument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NamedDocument>): NamedDocument {
    const message = createBaseNamedDocument();
    message.fields = object.fields?.map((e) => FieldEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchIndexDocumentsRequest(): BatchIndexDocumentsRequest {
  return { indexName: "", documents: [] };
}

export const BatchIndexDocumentsRequest: MessageFns<BatchIndexDocumentsRequest> = {
  encode(message: BatchIndexDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    for (const v of message.documents) {
      NamedDocument.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchIndexDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchIndexDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.documents.push(NamedDocument.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchIndexDocumentsRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => NamedDocument.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchIndexDocumentsRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => NamedDocument.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchIndexDocumentsRequest>): BatchIndexDocumentsRequest {
    return BatchIndexDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchIndexDocumentsRequest>): BatchIndexDocumentsRequest {
    const message = createBaseBatchIndexDocumentsRequest();
    message.indexName = object.indexName ?? "";
    message.documents = object.documents?.map((e) => NamedDocument.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchIndexDocumentsResponse(): BatchIndexDocumentsResponse {
  return { indexedCount: 0, errorCount: 0 };
}

export const BatchIndexDocumentsResponse: MessageFns<BatchIndexDocumentsResponse> = {
  encode(message: BatchIndexDocumentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexedCount !== 0) {
      writer.uint32(8).uint32(message.indexedCount);
    }
    if (message.errorCount !== 0) {
      writer.uint32(16).uint32(message.errorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchIndexDocumentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchIndexDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.indexedCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.errorCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchIndexDocumentsResponse {
    return {
      indexedCount: isSet(object.indexedCount)
        ? globalThis.Number(object.indexedCount)
        : isSet(object.indexed_count)
        ? globalThis.Number(object.indexed_count)
        : 0,
      errorCount: isSet(object.errorCount)
        ? globalThis.Number(object.errorCount)
        : isSet(object.error_count)
        ? globalThis.Number(object.error_count)
        : 0,
    };
  },

  toJSON(message: BatchIndexDocumentsResponse): unknown {
    const obj: any = {};
    if (message.indexedCount !== 0) {
      obj.indexedCount = Math.round(message.indexedCount);
    }
    if (message.errorCount !== 0) {
      obj.errorCount = Math.round(message.errorCount);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchIndexDocumentsResponse>): BatchIndexDocumentsResponse {
    return BatchIndexDocumentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchIndexDocumentsResponse>): BatchIndexDocumentsResponse {
    const message = createBaseBatchIndexDocumentsResponse();
    message.indexedCount = object.indexedCount ?? 0;
    message.errorCount = object.errorCount ?? 0;
    return message;
  },
};

function createBaseIndexDocumentRequest(): IndexDocumentRequest {
  return { indexName: "", fields: [] };
}

export const IndexDocumentRequest: MessageFns<IndexDocumentRequest> = {
  encode(message: IndexDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    for (const v of message.fields) {
      FieldEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(FieldEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexDocumentRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => FieldEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: IndexDocumentRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => FieldEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IndexDocumentRequest>): IndexDocumentRequest {
    return IndexDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexDocumentRequest>): IndexDocumentRequest {
    const message = createBaseIndexDocumentRequest();
    message.indexName = object.indexName ?? "";
    message.fields = object.fields?.map((e) => FieldEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIndexDocumentsResponse(): IndexDocumentsResponse {
  return { indexedCount: 0 };
}

export const IndexDocumentsResponse: MessageFns<IndexDocumentsResponse> = {
  encode(message: IndexDocumentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexedCount !== 0) {
      writer.uint32(8).uint32(message.indexedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexDocumentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.indexedCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexDocumentsResponse {
    return {
      indexedCount: isSet(object.indexedCount)
        ? globalThis.Number(object.indexedCount)
        : isSet(object.indexed_count)
        ? globalThis.Number(object.indexed_count)
        : 0,
    };
  },

  toJSON(message: IndexDocumentsResponse): unknown {
    const obj: any = {};
    if (message.indexedCount !== 0) {
      obj.indexedCount = Math.round(message.indexedCount);
    }
    return obj;
  },

  create(base?: DeepPartial<IndexDocumentsResponse>): IndexDocumentsResponse {
    return IndexDocumentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexDocumentsResponse>): IndexDocumentsResponse {
    const message = createBaseIndexDocumentsResponse();
    message.indexedCount = object.indexedCount ?? 0;
    return message;
  },
};

function createBaseCommitRequest(): CommitRequest {
  return { indexName: "" };
}

export const CommitRequest: MessageFns<CommitRequest> = {
  encode(message: CommitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
    };
  },

  toJSON(message: CommitRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    return obj;
  },

  create(base?: DeepPartial<CommitRequest>): CommitRequest {
    return CommitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitRequest>): CommitRequest {
    const message = createBaseCommitRequest();
    message.indexName = object.indexName ?? "";
    return message;
  },
};

function createBaseCommitResponse(): CommitResponse {
  return { success: false, numDocs: 0 };
}

export const CommitResponse: MessageFns<CommitResponse> = {
  encode(message: CommitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.numDocs !== 0) {
      writer.uint32(16).uint32(message.numDocs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numDocs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      numDocs: isSet(object.numDocs)
        ? globalThis.Number(object.numDocs)
        : isSet(object.num_docs)
        ? globalThis.Number(object.num_docs)
        : 0,
    };
  },

  toJSON(message: CommitResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.numDocs !== 0) {
      obj.numDocs = Math.round(message.numDocs);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitResponse>): CommitResponse {
    return CommitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitResponse>): CommitResponse {
    const message = createBaseCommitResponse();
    message.success = object.success ?? false;
    message.numDocs = object.numDocs ?? 0;
    return message;
  },
};

function createBaseForceMergeRequest(): ForceMergeRequest {
  return { indexName: "" };
}

export const ForceMergeRequest: MessageFns<ForceMergeRequest> = {
  encode(message: ForceMergeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForceMergeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceMergeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForceMergeRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
    };
  },

  toJSON(message: ForceMergeRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    return obj;
  },

  create(base?: DeepPartial<ForceMergeRequest>): ForceMergeRequest {
    return ForceMergeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForceMergeRequest>): ForceMergeRequest {
    const message = createBaseForceMergeRequest();
    message.indexName = object.indexName ?? "";
    return message;
  },
};

function createBaseForceMergeResponse(): ForceMergeResponse {
  return { success: false, numSegments: 0 };
}

export const ForceMergeResponse: MessageFns<ForceMergeResponse> = {
  encode(message: ForceMergeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.numSegments !== 0) {
      writer.uint32(16).uint32(message.numSegments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForceMergeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceMergeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numSegments = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForceMergeResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      numSegments: isSet(object.numSegments)
        ? globalThis.Number(object.numSegments)
        : isSet(object.num_segments)
        ? globalThis.Number(object.num_segments)
        : 0,
    };
  },

  toJSON(message: ForceMergeResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.numSegments !== 0) {
      obj.numSegments = Math.round(message.numSegments);
    }
    return obj;
  },

  create(base?: DeepPartial<ForceMergeResponse>): ForceMergeResponse {
    return ForceMergeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForceMergeResponse>): ForceMergeResponse {
    const message = createBaseForceMergeResponse();
    message.success = object.success ?? false;
    message.numSegments = object.numSegments ?? 0;
    return message;
  },
};

function createBaseDeleteIndexRequest(): DeleteIndexRequest {
  return { indexName: "" };
}

export const DeleteIndexRequest: MessageFns<DeleteIndexRequest> = {
  encode(message: DeleteIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
    };
  },

  toJSON(message: DeleteIndexRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    return DeleteIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    const message = createBaseDeleteIndexRequest();
    message.indexName = object.indexName ?? "";
    return message;
  },
};

function createBaseDeleteIndexResponse(): DeleteIndexResponse {
  return { success: false };
}

export const DeleteIndexResponse: MessageFns<DeleteIndexResponse> = {
  encode(message: DeleteIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteIndexResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexResponse>): DeleteIndexResponse {
    return DeleteIndexResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexResponse>): DeleteIndexResponse {
    const message = createBaseDeleteIndexResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListIndexesRequest(): ListIndexesRequest {
  return {};
}

export const ListIndexesRequest: MessageFns<ListIndexesRequest> = {
  encode(_: ListIndexesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListIndexesRequest {
    return {};
  },

  toJSON(_: ListIndexesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    return ListIndexesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    const message = createBaseListIndexesRequest();
    return message;
  },
};

function createBaseListIndexesResponse(): ListIndexesResponse {
  return { indexNames: [] };
}

export const ListIndexesResponse: MessageFns<ListIndexesResponse> = {
  encode(message: ListIndexesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesResponse {
    return {
      indexNames: globalThis.Array.isArray(object?.indexNames)
        ? object.indexNames.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.index_names)
        ? object.index_names.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListIndexesResponse): unknown {
    const obj: any = {};
    if (message.indexNames?.length) {
      obj.indexNames = message.indexNames;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    return ListIndexesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    const message = createBaseListIndexesResponse();
    message.indexNames = object.indexNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseRetrainVectorIndexRequest(): RetrainVectorIndexRequest {
  return { indexName: "" };
}

export const RetrainVectorIndexRequest: MessageFns<RetrainVectorIndexRequest> = {
  encode(message: RetrainVectorIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexName !== "") {
      writer.uint32(10).string(message.indexName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrainVectorIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrainVectorIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrainVectorIndexRequest {
    return {
      indexName: isSet(object.indexName)
        ? globalThis.String(object.indexName)
        : isSet(object.index_name)
        ? globalThis.String(object.index_name)
        : "",
    };
  },

  toJSON(message: RetrainVectorIndexRequest): unknown {
    const obj: any = {};
    if (message.indexName !== "") {
      obj.indexName = message.indexName;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrainVectorIndexRequest>): RetrainVectorIndexRequest {
    return RetrainVectorIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrainVectorIndexRequest>): RetrainVectorIndexRequest {
    const message = createBaseRetrainVectorIndexRequest();
    message.indexName = object.indexName ?? "";
    return message;
  },
};

function createBaseRetrainVectorIndexResponse(): RetrainVectorIndexResponse {
  return { success: false };
}

export const RetrainVectorIndexResponse: MessageFns<RetrainVectorIndexResponse> = {
  encode(message: RetrainVectorIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrainVectorIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrainVectorIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrainVectorIndexResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RetrainVectorIndexResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrainVectorIndexResponse>): RetrainVectorIndexResponse {
    return RetrainVectorIndexResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrainVectorIndexResponse>): RetrainVectorIndexResponse {
    const message = createBaseRetrainVectorIndexResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/** Search service */
export type SearchServiceDefinition = typeof SearchServiceDefinition;
export const SearchServiceDefinition = {
  name: "SearchService",
  fullName: "hermes.SearchService",
  methods: {
    /** Search for documents */
    search: {
      name: "Search",
      requestType: SearchRequest,
      requestStream: false,
      responseType: SearchResponse,
      responseStream: false,
      options: {},
    },
    /** Get document by ID */
    getDocument: {
      name: "GetDocument",
      requestType: GetDocumentRequest,
      requestStream: false,
      responseType: GetDocumentResponse,
      responseStream: false,
      options: {},
    },
    /** Get index info */
    getIndexInfo: {
      name: "GetIndexInfo",
      requestType: GetIndexInfoRequest,
      requestStream: false,
      responseType: GetIndexInfoResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

/** Index service */
export type IndexServiceDefinition = typeof IndexServiceDefinition;
export const IndexServiceDefinition = {
  name: "IndexService",
  fullName: "hermes.IndexService",
  methods: {
    /** Create a new index (supports both structured schema and SDL string) */
    createIndex: {
      name: "CreateIndex",
      requestType: CreateIndexRequest,
      requestStream: false,
      responseType: CreateIndexResponse,
      responseStream: false,
      options: {},
    },
    /** Add documents to index (streaming) */
    indexDocuments: {
      name: "IndexDocuments",
      requestType: IndexDocumentRequest,
      requestStream: true,
      responseType: IndexDocumentsResponse,
      responseStream: false,
      options: {},
    },
    /** Add documents in batch */
    batchIndexDocuments: {
      name: "BatchIndexDocuments",
      requestType: BatchIndexDocumentsRequest,
      requestStream: false,
      responseType: BatchIndexDocumentsResponse,
      responseStream: false,
      options: {},
    },
    /** Commit pending changes */
    commit: {
      name: "Commit",
      requestType: CommitRequest,
      requestStream: false,
      responseType: CommitResponse,
      responseStream: false,
      options: {},
    },
    /** Force merge segments */
    forceMerge: {
      name: "ForceMerge",
      requestType: ForceMergeRequest,
      requestStream: false,
      responseType: ForceMergeResponse,
      responseStream: false,
      options: {},
    },
    /** Delete an index */
    deleteIndex: {
      name: "DeleteIndex",
      requestType: DeleteIndexRequest,
      requestStream: false,
      responseType: DeleteIndexResponse,
      responseStream: false,
      options: {},
    },
    /** List all indexes */
    listIndexes: {
      name: "ListIndexes",
      requestType: ListIndexesRequest,
      requestStream: false,
      responseType: ListIndexesResponse,
      responseStream: false,
      options: {},
    },
    /** Retrain vector index (re-cluster centroids/codebooks from current data) */
    retrainVectorIndex: {
      name: "RetrainVectorIndex",
      requestType: RetrainVectorIndexRequest,
      requestStream: false,
      responseType: RetrainVectorIndexResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
