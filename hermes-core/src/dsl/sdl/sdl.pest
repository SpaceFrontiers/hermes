// Hermes Schema Definition Language (SDL) Grammar

// Main entry point - a file contains one or more index definitions
file = { SOI ~ index_def+ ~ EOI }

// Index definition
index_def = { "index" ~ identifier ~ "{" ~ (field_def | default_fields_def | query_router_def)* ~ "}" }

// Default fields definition
default_fields_def = { "default_fields" ~ ":" ~ "[" ~ identifier ~ ("," ~ identifier)* ~ "]" }

// Query router definition for routing queries to specific fields based on regex
// Example:
//   query_router {
//       pattern: r"10\.\d{4,}/[^\s]+"
//       substitution: "doi://{0}"
//       target_field: uris
//       mode: exclusive
//   }
query_router_def = { "query_router" ~ "{" ~ query_router_prop+ ~ "}" }

// Query router properties
query_router_prop = {
    query_router_pattern |
    query_router_substitution |
    query_router_target |
    query_router_mode
}

query_router_pattern = { "pattern" ~ ":" ~ regex_string }
query_router_substitution = { "substitution" ~ ":" ~ quoted_string }
query_router_target = { "target_field" ~ ":" ~ identifier }
query_router_mode = { "mode" ~ ":" ~ routing_mode }

// Routing mode: exclusive (only target field) or additional (target + default fields)
routing_mode = { "exclusive" | "additional" }

// Regex string: r"..." or just "..."
regex_string = { raw_string | quoted_string }
raw_string = @{ "r\"" ~ raw_string_inner ~ "\"" }
raw_string_inner = @{ (!("\"") ~ ANY)* }
quoted_string = @{ "\"" ~ string_inner ~ "\"" }
string_inner = @{ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* }

// Field definition with optional tokenizer
// Examples:
//   field title: text [indexed, stored]
//   field body: text<en_stem> [indexed]
//   field name: text<default> [indexed, stored]
//   field embedding: dense_vector<768> [indexed<rabitq, centroids: "c.bin">]
//   field embedding: dense_vector<dims: 768, mrl_dim: 256> [indexed<scann, centroids: "c.bin", codebook: "pq.bin">]
field_def = { "field" ~ identifier ~ ":" ~ field_type ~ (sparse_vector_config | dense_vector_config | tokenizer_spec)? ~ attributes? }

// Field types
field_type = {
    "text" | "string" | "str" |
    "u64" | "uint" | "unsigned" |
    "i64" | "int" | "integer" |
    "f64" | "float" | "double" |
    "bytes" | "binary" | "blob" |
    "json" |
    "sparse_vector" |
    "dense_vector" | "vector"
}

// Sparse vector configuration - only index_size (positional)
// Quantization and weight_threshold go in indexed<...> attribute
// Examples:
//   field embedding: sparse_vector [indexed, stored]
//   field embedding: sparse_vector<u16> [indexed]
//   field embedding: sparse_vector<u32> [indexed<quantization: uint8, weight_threshold: 0.1>]
sparse_vector_config = { "<" ~ index_size_spec ~ ">" }
index_size_spec = { "u16" | "u32" }
quantization_spec = { "float32" | "float16" | "uint8" | "uint4" | "f32" | "f16" | "u8" | "u4" }
weight_threshold_spec = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

// Dense vector configuration - only dimension
// All index-related params (index type, centroids, codebook, nprobe, mrl_dim) are in indexed<...>
// Examples:
//   field embedding: dense_vector<768> [indexed]
//   field embedding: dense_vector<768> [indexed<rabitq, centroids: "c.bin">]
//   field embedding: dense_vector<768> [indexed<scann, centroids: "c.bin", codebook: "pq.bin", nprobe: 64, mrl_dim: 256>]
//   field embedding: dense_vector<768> [stored]  # not indexed, just stored
dense_vector_config = { "<" ~ dense_vector_params ~ ">" }
dense_vector_params = { dense_vector_keyword_params | dense_vector_positional_params }

// Keyword-based params: only dims (index params moved to indexed<...>)
dense_vector_keyword_params = { dims_kwarg }
dims_kwarg = { "dims" ~ ":" ~ dimension_spec }

// Positional params: just dimension
dense_vector_positional_params = { dimension_spec }

dimension_spec = @{ ASCII_DIGIT+ }

// Tokenizer specification: <tokenizer_name>
tokenizer_spec = { "<" ~ identifier ~ ">" }

// Attributes like [indexed, stored, multi]
// indexed can have optional index config for dense vectors: indexed<rabitq, centroids: "path">
attributes = { "[" ~ attribute ~ ("," ~ attribute)* ~ "]" }
attribute = { indexed_with_config | "indexed" | "stored" | "multi" }

// Indexed attribute with optional vector index configuration
// Examples:
//   indexed
//   indexed<rabitq>
//   indexed<rabitq, centroids: "centroids.bin">
//   indexed<rabitq, centroids: "c.bin", nprobe: 64>
//   indexed<scann, centroids: "c.bin", codebook: "pq.bin", mrl_dim: 256>
//   indexed<quantization: uint8, weight_threshold: 0.1>  # for sparse vectors
//   indexed<quantization: uint8, query<tokenizer: "model/name", weighting: idf>>  # with query config
indexed_with_config = { "indexed" ~ "<" ~ index_config_params ~ ">" }
index_config_params = { index_config_param ~ ("," ~ index_config_param)* }
index_config_param = { index_type_kwarg | centroids_kwarg | codebook_kwarg | nprobe_kwarg | mrl_dim_kwarg | quantization_kwarg | weight_threshold_kwarg | query_config_block | index_type_spec }
mrl_dim_kwarg = { "mrl_dim" ~ ":" ~ mrl_dim_spec }
mrl_dim_spec = @{ ASCII_DIGIT+ }
index_type_kwarg = { "index" ~ ":" ~ index_type_spec }
index_type_spec = { "scann" | "rabitq" }
centroids_kwarg = { "centroids" ~ ":" ~ centroids_path }
codebook_kwarg = { "codebook" ~ ":" ~ codebook_path }
nprobe_kwarg = { "nprobe" ~ ":" ~ nprobe_spec }
quantization_kwarg = { "quantization" ~ ":" ~ quantization_spec }
weight_threshold_kwarg = { "weight_threshold" ~ ":" ~ weight_threshold_spec }
centroids_path = { "\"" ~ path_chars ~ "\"" }
codebook_path = { "\"" ~ path_chars ~ "\"" }
path_chars = @{ (!("\"" ) ~ ANY)* }
nprobe_spec = @{ ASCII_DIGIT+ }

// Query-time configuration for sparse vectors
// Example: query<tokenizer: "model/name", weighting: idf>
query_config_block = { "query" ~ "<" ~ query_config_params ~ ">" }
query_config_params = { query_config_param ~ ("," ~ query_config_param)* }
query_config_param = { query_tokenizer_kwarg | query_weighting_kwarg }
query_tokenizer_kwarg = { "tokenizer" ~ ":" ~ tokenizer_path }
query_weighting_kwarg = { "weighting" ~ ":" ~ weighting_spec }
tokenizer_path = { "\"" ~ path_chars ~ "\"" }
weighting_spec = { "one" | "idf" }

// Identifier (field names, index names, tokenizer names)
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }
