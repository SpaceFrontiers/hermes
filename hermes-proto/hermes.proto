syntax = "proto3";

package hermes;

// Search service
service SearchService {
  // Search for documents
  rpc Search(SearchRequest) returns (SearchResponse);

  // Get document by ID
  rpc GetDocument(GetDocumentRequest) returns (GetDocumentResponse);

  // Get index info
  rpc GetIndexInfo(GetIndexInfoRequest) returns (GetIndexInfoResponse);
}

// Index service
service IndexService {
  // Create a new index (supports both structured schema and SDL string)
  rpc CreateIndex(CreateIndexRequest) returns (CreateIndexResponse);

  // Add documents to index (streaming)
  rpc IndexDocuments(stream IndexDocumentRequest) returns (IndexDocumentsResponse);

  // Add documents in batch
  rpc BatchIndexDocuments(BatchIndexDocumentsRequest) returns (BatchIndexDocumentsResponse);

  // Commit pending changes
  rpc Commit(CommitRequest) returns (CommitResponse);

  // Force merge segments
  rpc ForceMerge(ForceMergeRequest) returns (ForceMergeResponse);

  // Delete an index
  rpc DeleteIndex(DeleteIndexRequest) returns (DeleteIndexResponse);

  // List all indexes
  rpc ListIndexes(ListIndexesRequest) returns (ListIndexesResponse);

  // Retrain vector index (re-cluster centroids/codebooks from current data)
  rpc RetrainVectorIndex(RetrainVectorIndexRequest) returns (RetrainVectorIndexResponse);
}

// Query types
message Query {
  oneof query {
    TermQuery term = 1;
    BooleanQuery boolean = 2;
    BoostQuery boost = 3;
    AllQuery all = 4;
    SparseVectorQuery sparse_vector = 5;
    DenseVectorQuery dense_vector = 6;
    MatchQuery match = 7;
  }
}

// How to combine scores for multi-valued documents
enum MultiValueCombiner {
  COMBINER_LOG_SUM_EXP = 0;  // Log-sum-exp smooth maximum (default)
  COMBINER_MAX = 1;          // Take maximum score
  COMBINER_AVG = 2;          // Average all scores
  COMBINER_SUM = 3;          // Sum all scores
  COMBINER_WEIGHTED_TOP_K = 4;  // Weighted top-k with decay
}

// Sparse vector query for similarity search
// Either provide (indices, values) directly, or provide text for server-side tokenization
message SparseVectorQuery {
  string field = 1;
  repeated uint32 indices = 2;   // Pre-computed token indices
  repeated float values = 3;     // Pre-computed token values
  string text = 4;               // Raw text (tokenized server-side if tokenizer configured)
  MultiValueCombiner combiner = 5;  // How to combine scores for multi-value fields
  float heap_factor = 6;         // Approximate search factor (1.0 = exact, 0.8 = ~20% faster)
  float combiner_temperature = 7;   // Temperature for LogSumExp (default: 1.5)
  uint32 combiner_top_k = 8;        // K for WeightedTopK (default: 5)
  float combiner_decay = 9;         // Decay for WeightedTopK (default: 0.7)
  float weight_threshold = 10;      // Min abs(weight) for query dims (0 = no filtering)
  uint32 max_query_dims = 11;       // Max query dimensions to process (0 = all)
  float pruning = 12;               // Fraction of query dims to keep (0 = no pruning, 0.1 = top 10%)
}

// Dense vector query for similarity search
message DenseVectorQuery {
  string field = 1;
  repeated float vector = 2;
  uint32 nprobe = 3;           // Number of clusters to probe (for IVF indexes)
  uint32 rerank_factor = 4;    // Re-ranking factor (multiplied by k)
  MultiValueCombiner combiner = 5;  // How to combine scores for multi-value fields
  float combiner_temperature = 6;   // Temperature for LogSumExp (default: 1.5)
  uint32 combiner_top_k = 7;        // K for WeightedTopK (default: 5)
  float combiner_decay = 8;         // Decay for WeightedTopK (default: 0.7)
}

message TermQuery {
  string field = 1;
  string term = 2;
}

message BooleanQuery {
  repeated Query must = 1;
  repeated Query should = 2;
  repeated Query must_not = 3;
}

message BoostQuery {
  Query query = 1;
  float boost = 2;
}

message AllQuery {}

// Full-text match query - tokenizes text server-side and searches as OR of tokens
// Use this instead of TermQuery when searching with natural language text
message MatchQuery {
  string field = 1;
  string text = 2;
}

// L2 reranker: rerank L1 candidates by exact dense vector distance
message Reranker {
  string field = 1;                    // Dense vector field (must be stored)
  repeated float vector = 2;           // Query vector
  uint32 limit = 3;                    // L1 candidate count (0 = 10x final limit)
  MultiValueCombiner combiner = 4;
  float combiner_temperature = 5;
  uint32 combiner_top_k = 6;
  float combiner_decay = 7;
  uint32 matryoshka_dims = 8;          // Matryoshka pre-filter dims (0 = disabled)
}

// Fast-field filter for efficient document filtering
message Filter {
  string field = 1;
  oneof condition {
    uint64 eq_u64 = 2;
    int64 eq_i64 = 3;
    double eq_f64 = 4;
    string eq_text = 5;
    RangeFilter range = 6;
    InFilter in_values = 7;
  }
}

// Numeric range filter (inclusive bounds)
message RangeFilter {
  optional double min = 1;
  optional double max = 2;
}

// Set membership filter
message InFilter {
  repeated string text_values = 1;
  repeated uint64 u64_values = 2;
  repeated int64 i64_values = 3;
}

// Search request/response
message SearchRequest {
  string index_name = 1;
  Query query = 2;
  uint32 limit = 3;
  uint32 offset = 4;
  repeated string fields_to_load = 5;
  Reranker reranker = 6;               // Optional L2 reranker
  repeated Filter filters = 7;         // Fast-field filters
}

// Unique document address: segment + local doc_id
message DocAddress {
  string segment_id = 1;          // Segment ID (hex, 32 chars)
  uint32 doc_id = 2;              // Segment-local document ID
}

message SearchHit {
  DocAddress address = 1;
  float score = 2;
  map<string, FieldValue> fields = 3;
  repeated OrdinalScore ordinal_scores = 4;  // Per-ordinal scores for multi-value fields
}

// Score contribution from a specific ordinal in a multi-valued field
message OrdinalScore {
  uint32 ordinal = 1;  // Which value in the multi-valued field (0-indexed)
  float score = 2;     // Score contribution from this ordinal
}

message FieldValue {
  oneof value {
    string text = 1;
    uint64 u64 = 2;
    int64 i64 = 3;
    double f64 = 4;
    bytes bytes_value = 5;
    SparseVector sparse_vector = 6;
    DenseVector dense_vector = 7;
    string json_value = 8;  // JSON serialized as string
  }
}

// Sparse vector with term indices and weights
message SparseVector {
  repeated uint32 indices = 1;
  repeated float values = 2;
}

// Dense vector (float32 values)
message DenseVector {
  repeated float values = 1;
}

message SearchResponse {
  repeated SearchHit hits = 1;
  uint32 total_hits = 2;
  uint64 took_ms = 3;
  SearchTimings timings = 4;
}

// Detailed timing breakdown for search phases (all values in microseconds)
message SearchTimings {
  uint64 search_us = 1;       // L1 retrieval (query scoring across segments)
  uint64 rerank_us = 2;       // L2 reranking (dense vector rescoring)
  uint64 load_us = 3;         // Document field loading from store
  uint64 total_us = 4;        // Wall-clock total (includes overhead)
}

// Get document request/response
message GetDocumentRequest {
  string index_name = 1;
  DocAddress address = 2;
}

message GetDocumentResponse {
  map<string, FieldValue> fields = 1;
}

// Index info request/response
message GetIndexInfoRequest {
  string index_name = 1;
}

message GetIndexInfoResponse {
  string index_name = 1;
  uint32 num_docs = 2;
  uint32 num_segments = 3;
  // Schema in SDL format
  string schema = 4;
  // Memory usage breakdown (if available)
  MemoryStats memory_stats = 5;
  // Per-field vector statistics
  repeated VectorFieldStats vector_stats = 6;
}

// Per-field vector statistics (dense or sparse)
message VectorFieldStats {
  string field_name = 1;
  string vector_type = 2;  // "dense" or "sparse"
  uint64 total_vectors = 3;
  uint32 dimension = 4;    // dim for dense, num_dimensions for sparse
}

// Memory usage statistics
message MemoryStats {
  // Total estimated memory usage in bytes
  uint64 total_bytes = 1;
  // Indexing buffer memory (pending documents not yet flushed)
  IndexingBufferStats indexing_buffer = 2;
  // Segment reader memory (loaded for search)
  SegmentReaderStats segment_reader = 3;
}

// Indexing buffer memory breakdown
message IndexingBufferStats {
  uint64 total_bytes = 1;
  uint64 postings_bytes = 2;
  uint64 sparse_vectors_bytes = 3;
  uint64 dense_vectors_bytes = 4;
  uint64 interner_bytes = 5;
  uint64 position_index_bytes = 6;
  uint32 pending_docs = 7;
  uint32 unique_terms = 8;
}

// Segment reader memory (search structures)
message SegmentReaderStats {
  uint64 total_bytes = 1;
  uint64 term_dict_cache_bytes = 2;
  uint64 store_cache_bytes = 3;
  uint64 sparse_index_bytes = 4;
  uint64 dense_index_bytes = 5;
  uint32 num_segments_loaded = 6;
}

// Create index request/response
message CreateIndexRequest {
  string index_name = 1;
  // Schema definition
  string schema = 2;
}

message CreateIndexResponse {
  bool success = 1;
}

// Field entry for multi-value field support
message FieldEntry {
  string name = 1;
  FieldValue value = 2;
}

// Named document for batch indexing
// Uses repeated FieldEntry to support multi-value fields (same name, multiple values)
message NamedDocument {
  repeated FieldEntry fields = 1;
}

// Batch index documents request
message BatchIndexDocumentsRequest {
  string index_name = 1;
  repeated NamedDocument documents = 2;
}

message BatchIndexDocumentsResponse {
  uint32 indexed_count = 1;
  uint32 error_count = 2;
}

// Index document request/response
message IndexDocumentRequest {
  string index_name = 1;
  repeated FieldEntry fields = 2;
}

message IndexDocumentsResponse {
  uint32 indexed_count = 1;
}

// Commit request/response
message CommitRequest {
  string index_name = 1;
}

message CommitResponse {
  bool success = 1;
  uint32 num_docs = 2;
}

// Force merge request/response
message ForceMergeRequest {
  string index_name = 1;
}

message ForceMergeResponse {
  bool success = 1;
  uint32 num_segments = 2;
}

// Delete index request/response
message DeleteIndexRequest {
  string index_name = 1;
}

message DeleteIndexResponse {
  bool success = 1;
}

// List indexes request/response
message ListIndexesRequest {}

message ListIndexesResponse {
  repeated string index_names = 1;
}

// Retrain vector index request/response
message RetrainVectorIndexRequest {
  string index_name = 1;
}

message RetrainVectorIndexResponse {
  bool success = 1;
}
